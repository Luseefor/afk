---
title: Overview
description: AFK package map, design choices, and practical adoption path.
---

## What AFK gives you

AFK gives you a stable way to build agent systems where orchestration, execution, and reliability are explicit.

<CardGroup cols={2}>
  <Card title="Agents" href="/library/agents" icon="bot">Behavior contracts, specialist delegation, A2A boundaries.</Card>
  <Card title="Core Runner" href="/library/core-runner" icon="play">Deterministic lifecycle and control semantics.</Card>
  <Card title="LLM Runtime" href="/llms/index" icon="sparkles">Provider portability with production policies.</Card>
  <Card title="Tools" href="/library/tools" icon="wrench">Typed side effects with policy and safety controls.</Card>
  <Card title="Memory" href="/library/memory" icon="database">State continuity, resume, and retention policy.</Card>
  <Card title="Reliability" href="/library/observability" icon="activity">Telemetry + evals for release confidence.</Card>
</CardGroup>

## Read this before implementing

- [Mental Model](/library/mental-model)
- [How to Use AFK](/library/how-to-use-afk)

## Fast architectural rule

If a behavior changes runtime outcomes, model it as a contract in code, not an implicit prompt-only convention.

## Builder perspective

For humans and coding agents:

1. Define interfaces first.
2. Keep orchestration in runner/core.
3. Keep adapter logic in module-specific implementations.
4. Add tests and eval cases for every new path.
