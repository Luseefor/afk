---
title: Architecture
description: Runtime architecture and module interaction model for AFK.
---

## System Contract

AFK architecture separates **orchestration ownership** from **execution adapters**.

- orchestration owner: `afk.core`
- adapters/providers: `afk.llms`, `afk.tools`, `afk.memory`, `afk.queues`
- assurance: `afk.observability`, `afk.evals`

## Interaction Map

```mermaid
flowchart LR
    App[Application] --> Runner[afk.core Runner]
    Runner --> Agent[afk.agents]
    Runner --> LLM[afk.llms]
    Runner --> Tools[afk.tools]
    Runner --> Memory[afk.memory]
    Runner --> Queue[afk.queues]
    Runner --> Obs[afk.observability]
    Runner --> Evals[afk.evals]
```

## Runtime sequence

```mermaid
sequenceDiagram
    participant App
    participant Runner
    participant LLM
    participant Tools
    participant Memory

    App->>Runner: start run
    Runner->>Memory: initialize state
    Runner->>LLM: request next action
    LLM-->>Runner: normalized response
    alt tool action
        Runner->>Tools: execute typed tool call
        Tools-->>Runner: output/error
    end
    Runner->>Memory: checkpoint + events
    Runner-->>App: terminal result
```

## Builder Checklist

- Keep orchestration decisions in runner/core only.
- Keep provider/tool/backend specifics inside adapter modules.
- Treat unknown/invalid contracts as terminal failures.
- Make telemetry failures non-fatal.

## For Coding Agents

When generating architecture-level changes:

1. never mix orchestration and provider logic in one module
2. add explicit type contracts before behavior
3. include failure path tests for timeout/cancel/invalid payload
